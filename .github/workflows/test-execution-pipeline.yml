name: Test Execution Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  workflow_dispatch:
    inputs:
      test_scope:
        description: "Test scope to run"
        required: false
        default: "all"
        type: choice
        options:
          - all
          - unit
          - integration
          - e2e
          - performance
          - load
      parallel_execution:
        description: "Enable parallel test execution"
        required: false
        default: true
        type: boolean
      fail_fast:
        description: "Stop on first failure"
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: "22"
  TEST_DATABASE_URL: postgresql://postgres:postgres@localhost:5432/jobpsych_test
  JWT_ACCESS_SECRET: test-jwt-access-secret-key-for-testing-purposes-only-32-chars
  JWT_REFRESH_SECRET: test-jwt-refresh-secret-key-for-testing-purposes-only-32-chars
  CORS_ORIGINS: http://localhost:3000,https://test.example.com

jobs:
  # Pre-test setup and validation
  setup-and-validate:
    name: "Setup & Validation"
    runs-on: ubuntu-latest
    outputs:
      test-matrix: ${{ steps.generate-matrix.outputs.matrix }}
      cache-key: ${{ steps.cache-key.outputs.key }}

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: jobpsych_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Cache test dependencies
        id: cache-key
        run: |
          echo "key=test-deps-${{ runner.os }}-${{ hashFiles('package-lock.json') }}-$(date +%Y%m%d)" >> $GITHUB_OUTPUT

      - name: Generate test matrix
        id: generate-matrix
        run: |
          SCOPE="${{ github.event.inputs.test_scope || 'all' }}"
          if [ "$SCOPE" = "all" ]; then
            MATRIX='["unit", "integration", "e2e", "performance"]'
          elif [ "$SCOPE" = "unit" ]; then
            MATRIX='["unit"]'
          elif [ "$SCOPE" = "integration" ]; then
            MATRIX='["integration"]'
          elif [ "$SCOPE" = "e2e" ]; then
            MATRIX='["e2e"]'
          elif [ "$SCOPE" = "performance" ]; then
            MATRIX='["performance"]'
          elif [ "$SCOPE" = "load" ]; then
            MATRIX='["load"]'
          else
            MATRIX='["unit", "integration", "e2e"]'
          fi
          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT

      - name: Setup test database
        run: |
          npm run db:migrate
        env:
          DATABASE_URL: ${{ env.TEST_DATABASE_URL }}

      - name: Validate test environment
        run: |
          echo "üîç Validating test environment..."
          node -e "
            console.log('‚úÖ Node.js version:', process.version);
            console.log('‚úÖ Platform:', process.platform);
            console.log('‚úÖ Architecture:', process.arch);
          "

          # Test database connection
          node -e "
            const { Client } = require('pg');
            const client = new Client({ connectionString: '${{ env.TEST_DATABASE_URL }}' });
            client.connect().then(() => {
              console.log('‚úÖ Database connection successful');
              return client.query('SELECT version()');
            }).then(result => {
              console.log('‚úÖ PostgreSQL version:', result.rows[0].version.split(' ')[1]);
              client.end();
            }).catch(err => {
              console.error('‚ùå Database connection failed:', err.message);
              process.exit(1);
            });
          "

      - name: Install Playwright browsers
        if: contains(fromJSON(steps.generate-matrix.outputs.matrix), 'e2e')
        run: npx playwright install --with-deps

      - name: Install Artillery
        if: contains(fromJSON(steps.generate-matrix.outputs.matrix), 'load') || contains(fromJSON(steps.generate-matrix.outputs.matrix), 'performance')
        run: npm install -g artillery

      - name: Pre-test health check
        run: |
          echo "üè• Running pre-test health checks..."
          # Build the application
          npm run build

          # Start application in background for health check
          npm start &
          SERVER_PID=$!

          # Wait for server to start
          timeout 30 bash -c 'until curl -f http://localhost:5000/api/auth/info; do sleep 1; done' || true

          # Run basic health check
          if curl -f http://localhost:5000/api/auth/info > /dev/null 2>&1; then
            echo "‚úÖ Application health check passed"
          else
            echo "‚ùå Application health check failed"
            kill $SERVER_PID 2>/dev/null || true
            exit 1
          fi

          # Cleanup
          kill $SERVER_PID 2>/dev/null || true

  # Parallel test execution
  test-execution:
    name: "Test Execution: ${{ matrix.test_type }}"
    runs-on: ubuntu-latest
    needs: setup-and-validate
    if: contains(fromJSON(needs.setup-and-validate.outputs.test-matrix), matrix.test_type)
    strategy:
      fail-fast: ${{ github.event.inputs.fail_fast == 'true' || false }}
      matrix:
        test_type: ${{ fromJSON(needs.setup-and-validate.outputs.test-matrix) }}

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: jobpsych_test_${{ matrix.test_type }}
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Restore cached dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.npm
            node_modules
          key: ${{ needs.setup-and-validate.outputs.cache-key }}

      - name: Install dependencies
        run: npm ci

      - name: Setup test database
        run: |
          npm run db:migrate
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/jobpsych_test_${{ matrix.test_type }}

      - name: Seed test data
        run: |
          echo "üå± Seeding test data for ${{ matrix.test_type }} tests..."
          node scripts/test-data-seeder.js ${{ matrix.test_type }}
        continue-on-error: true

      - name: Execute Unit Tests
        if: matrix.test_type == 'unit'
        run: |
          echo "üß™ Running Unit Tests..."
          npm run test:unit -- --testResultsProcessor=jest-junit --outputFile=test-results/unit-results.xml --coverage --coverageDirectory=coverage/unit

      - name: Execute Integration Tests
        if: matrix.test_type == 'integration'
        run: |
          echo "üîó Running Integration Tests..."
          # Start application server
          npm start &
          SERVER_PID=$!

          # Wait for server to be ready
          timeout 30 bash -c 'until curl -f http://localhost:5000/api/auth/info; do sleep 1; done'

          # Run integration tests
          npm run test:integration -- --testResultsProcessor=jest-junit --outputFile=test-results/integration-results.xml

          # Cleanup
          kill $SERVER_PID 2>/dev/null || true
        env:
          NODE_ENV: test

      - name: Execute E2E Tests
        if: matrix.test_type == 'e2e'
        run: |
          echo "üåê Running E2E Tests..."
          # Start application server
          npm start &
          SERVER_PID=$!

          # Wait for server to be ready
          timeout 30 bash -c 'until curl -f http://localhost:5000/api/auth/info; do sleep 1; done'

          # Run E2E tests
          npm run test:e2e:playwright -- --output=test-results/playwright-report

          # Cleanup
          kill $SERVER_PID 2>/dev/null || true
        env:
          NODE_ENV: test

      - name: Execute Performance Tests
        if: matrix.test_type == 'performance'
        run: |
          echo "‚ö° Running Performance Tests..."
          # Start application server
          npm start &
          SERVER_PID=$!

          # Wait for server to be ready
          timeout 30 bash -c 'until curl -f http://localhost:5000/api/auth/info; do sleep 1; done'

          # Run performance benchmark
          npm run perf:benchmark

          # Run performance monitor
          timeout 60 npm run perf:monitor &
          MONITOR_PID=$!

          # Run health checks
          node scripts/health-check.js

          # Cleanup
          kill $SERVER_PID 2>/dev/null || true
          kill $MONITOR_PID 2>/dev/null || true
        env:
          NODE_ENV: test

      - name: Execute Load Tests
        if: matrix.test_type == 'load'
        run: |
          echo "üî• Running Load Tests..."
          # Start application server
          npm start &
          SERVER_PID=$!

          # Wait for server to be ready
          timeout 30 bash -c 'until curl -f http://localhost:5000/api/auth/info; do sleep 1; done'

          # Run load tests
          npm run loadtest:auth || true
          npm run loadtest:rate-limit || true
          npm run loadtest:mixed || true

          # Generate load test reports
          npm run loadtest:report || true

          # Cleanup
          kill $SERVER_PID 2>/dev/null || true
        env:
          NODE_ENV: test

      - name: Upload test artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ matrix.test_type }}-${{ github.run_id }}
          path: |
            test-results/
            coverage/
            performance-results/
            artillery-reports/
            playwright-report/
          retention-days: 30

      - name: Generate test summary
        if: always()
        run: |
          echo "## Test Results: ${{ matrix.test_type }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Coverage summary
          if [ -f "coverage/${{ matrix.test_type }}/coverage-summary.json" ]; then
            LINES=$(jq '.total.lines.pct' coverage/${{ matrix.test_type }}/coverage-summary.json 2>/dev/null || echo "0")
            FUNCTIONS=$(jq '.total.functions.pct' coverage/${{ matrix.test_type }}/coverage-summary.json 2>/dev/null || echo "0")
            BRANCHES=$(jq '.total.branches.pct' coverage/${{ matrix.test_type }}/coverage-summary.json 2>/dev/null || echo "0")
            STATEMENTS=$(jq '.total.statements.pct' coverage/${{ matrix.test_type }}/coverage-summary.json 2>/dev/null || echo "0")
            echo "### Coverage Report" >> $GITHUB_STEP_SUMMARY
            echo "- Lines: ${LINES}%" >> $GITHUB_STEP_SUMMARY
            echo "- Functions: ${FUNCTIONS}%" >> $GITHUB_STEP_SUMMARY
            echo "- Branches: ${BRANCHES}%" >> $GITHUB_STEP_SUMMARY
            echo "- Statements: ${STATEMENTS}%" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Performance results
          if [ -d "performance-results" ] && [ "${{ matrix.test_type }}" = "performance" ]; then
            echo "### Performance Results" >> $GITHUB_STEP_SUMMARY
            ls -la performance-results/ >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Load test results
          if [ -d "artillery-reports" ] && [ "${{ matrix.test_type }}" = "load" ]; then
            echo "### Load Test Results" >> $GITHUB_STEP_SUMMARY
            ls -la artillery-reports/ >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

  # Test data management and cleanup
  test-data-management:
    name: "Test Data Management"
    runs-on: ubuntu-latest
    needs: test-execution
    if: always()

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Analyze test data usage
        run: |
          echo "üìä Analyzing test data usage..."
          node scripts/test-data-analyzer.js

      - name: Clean up test databases
        run: |
          echo "üßπ Cleaning up test databases..."
          # This would typically connect to a test database management system
          # For now, we'll just log the cleanup actions
          echo "‚úÖ Test database cleanup completed"

      - name: Archive test artifacts
        run: |
          echo "üì¶ Archiving test artifacts..."
          mkdir -p test-archive
          cp -r test-results test-archive/ 2>/dev/null || true
          cp -r coverage test-archive/ 2>/dev/null || true
          cp -r performance-results test-archive/ 2>/dev/null || true
          cp -r artillery-reports test-archive/ 2>/dev/null || true

          # Create archive
          tar -czf test-archive-${{ github.run_id }}.tar.gz test-archive/ 2>/dev/null || true

      - name: Upload test archive
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-archive-${{ github.run_id }}
          path: test-archive-${{ github.run_id }}.tar.gz
          retention-days: 90

  # Failure analysis and debugging
  failure-analysis:
    name: "Failure Analysis & Debugging"
    runs-on: ubuntu-latest
    needs: [setup-and-validate, test-execution, test-data-management]
    if: failure()

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Download test artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts

      - name: Analyze test failures
        run: |
          echo "üîç Analyzing test failures..."

          # Check for test result files
          find artifacts -name "*.xml" -o -name "*results*" -o -name "*report*" | head -20

          # Analyze Jest results
          if [ -f "artifacts/test-results-*/test-results/unit-results.xml" ]; then
            echo "üìã Unit Test Failures:" >> $GITHUB_STEP_SUMMARY
            grep -A 5 -B 5 "failure" artifacts/test-results-*/test-results/unit-results.xml || echo "No failures found"
          fi

          # Analyze performance issues
          if [ -d "artifacts/test-results-*/performance-results" ]; then
            echo "‚ö° Performance Issues:" >> $GITHUB_STEP_SUMMARY
            find artifacts/test-results-*/performance-results -name "*.json" -exec jq '.issues // empty' {} \; 2>/dev/null || echo "No performance issues found"
          fi

      - name: Generate failure report
        run: |
          echo "## üö® Test Failure Analysis Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Failed Jobs" >> $GITHUB_STEP_SUMMARY
          echo "- $(echo '${{ toJSON(needs) }}' | jq -r '. | to_entries[] | select(.value.result == "failure") | .key' | tr '\n' '\n- ')" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Debugging Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Check test logs above for specific error messages" >> $GITHUB_STEP_SUMMARY
          echo "2. Review test artifacts for detailed failure information" >> $GITHUB_STEP_SUMMARY
          echo "3. Run failed tests locally with \`npm run test:verbose\`" >> $GITHUB_STEP_SUMMARY
          echo "4. Check database connectivity and test data seeding" >> $GITHUB_STEP_SUMMARY
          echo "5. Verify environment variables and service dependencies" >> $GITHUB_STEP_SUMMARY

      - name: Collect debug information
        run: |
          echo "üêõ Collecting debug information..."
          mkdir -p debug-info

          # System information
          echo "System Info:" > debug-info/system.txt
          uname -a >> debug-info/system.txt
          node --version >> debug-info/system.txt
          npm --version >> debug-info/system.txt

          # Environment variables (safe ones only)
          echo "Environment:" > debug-info/environment.txt
          env | grep -E "(NODE_ENV|CI|GITHUB_)" | sort >> debug-info/environment.txt

          # Package information
          npm list --depth=0 > debug-info/packages.txt 2>/dev/null || true

      - name: Upload debug artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: debug-info-${{ github.run_id }}
          path: debug-info/
          retention-days: 30

  # Final reporting and notification
  test-reporting:
    name: "Test Reporting & Notification"
    runs-on: ubuntu-latest
    needs:
      [
        setup-and-validate,
        test-execution,
        test-data-management,
        failure-analysis,
      ]
    if: always()

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all test artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./all-artifacts

      - name: Generate comprehensive test report
        run: |
          echo "# üß™ Comprehensive Test Execution Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Test Run Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Workflow:** ${{ github.workflow }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Overall status
          if [ "${{ needs.test-execution.result }}" = "success" ]; then
            echo "‚úÖ **Overall Status: PASSED**" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Overall Status: FAILED**" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          # Test execution results
          echo "## Test Execution Results" >> $GITHUB_STEP_SUMMARY
          echo "| Test Type | Status | Duration |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|----------|" >> $GITHUB_STEP_SUMMARY

          # This would be enhanced with actual timing data from jobs
          echo "| Unit Tests | ${{ needs.test-execution.result }} | - |" >> $GITHUB_STEP_SUMMARY
          echo "| Integration Tests | ${{ needs.test-execution.result }} | - |" >> $GITHUB_STEP_SUMMARY
          echo "| E2E Tests | ${{ needs.test-execution.result }} | - |" >> $GITHUB_STEP_SUMMARY
          echo "| Performance Tests | ${{ needs.test-execution.result }} | - |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Coverage summary
          echo "## Code Coverage Summary" >> $GITHUB_STEP_SUMMARY
          find all-artifacts -name "coverage-summary.json" -exec jq -r '"- **" + (. | tostring) + "** coverage achieved"' {} \; 2>/dev/null || echo "- Coverage data not available" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Recommendations
          echo "## Recommendations" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.failure-analysis.result }}" = "failure" ]; then
            echo "‚ùå **Action Required:** Test failures detected. See failure analysis above." >> $GITHUB_STEP_SUMMARY
          else
            echo "‚úÖ **All tests passed.** Ready for deployment." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Send notification
        if: always()
        run: |
          # This would integrate with Slack, Teams, or other notification systems
          echo "üì¢ Test execution completed"
          echo "Status: ${{ needs.test-execution.result }}"
          echo "Run: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          # Example: Send to Slack (would require SLACK_WEBHOOK secret)
          # curl -X POST -H 'Content-type: application/json' \
          #   --data "{\"text\":\"Test execution completed: ${{ needs.test-execution.result }}\"}" \
          #   $SLACK_WEBHOOK

  # Quality gate
  quality-gate:
    name: "Quality Gate"
    runs-on: ubuntu-latest
    needs: [test-execution, test-reporting]
    if: always()

    steps:
      - name: Quality assessment
        run: |
          echo "üîí Running quality gate checks..."

          # Define quality thresholds
          COVERAGE_THRESHOLD=80
          PERF_THRESHOLD=500  # ms

          # Check if all required tests passed
          if [ "${{ needs.test-execution.result }}" != "success" ]; then
            echo "‚ùå Quality Gate: FAILED - Test execution failed"
            exit 1
          fi

          # Additional quality checks would go here
          # - Coverage thresholds
          # - Performance benchmarks
          # - Security scans

          echo "‚úÖ Quality Gate: PASSED"
          echo "üöÄ Code is ready for deployment"

      - name: Update deployment status
        if: success()
        run: |
          echo "deployment_ready=true" >> $GITHUB_ENV

      - name: Block deployment on failure
        if: failure()
        run: |
          echo "‚ùå Deployment blocked due to quality gate failure"
          echo "Please review test results and fix issues before deploying"
          exit 1
